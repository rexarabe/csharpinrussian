Лекция 3 

Объектно-ориентированное программирование в языке C# 

OOP Concepts 
Class 
Encapsulation 
Abstraction
Object
Inheritance
Polymorphism

План

1. Понятие класса в C#. 
2. Инкапсуляция, наследование и полиморфизм. 
3. Интерфейсы. 
4. Перегрузка операторов.
5. Преобразование типов. 
6. Класс System. Object.

Класс в объектно-ориентированном программировании - это тип данных, создаваемый программистом. 
Каждый класс описывает некоторую сущность предметной области программы (окно, базу данных, вычислительный процесс и т.п.).
Атрибуты класса (его свойства) представляют собой поля. 
Для реализации поведения объекта используются методы. 

В C# классы определяются с помощью ключевого слова class (класс).
Это можно делать внутри и за пределами пространства имен, внутри другого класса. 
Чаще всего определения классов помещаются в отдельные файлы. 
Например:

class Complex
{
  //Описание полей
  double re;
  double im;
  //Описание методов
  public Complex()
  {
    re = im = 0;
  }
  // ...
}

Кроме обычных методов, реализующих всю необходимую функциональность класса, используются также и специальные методы, которые называются конструкторами. 

Конструкторы автоматически вызываются при создании нового объекта данного класса и предназначены для инициализации объекта. 
Имя конструктора должно совпадать с названием класса. 
Конструкторов у класса может быть несколько. 
Они должны различаться поличеством и/или типов аргументов (иметь разные сигнатуры).

Если в классе не определено ни одного конструктора, то для этого класса автоматически создается конструктор по умолчанию, не имеющий параметров. 

Для создания объекта класса используется оператор new, выделяющий для него память и вызывающий соответствующий конструктор.

Например: 

Complex val = new Complex();

Ключевое слово this представляет ссылку на текущий экземпляр класса. 
Оно, например, может быть использовано для избежания дублирования функциональности конструкторов. 

Например: 

class Person
{
  string name; 
  int age;
  public Person() : this("Unknown"){}
  public Person(string name) : this(name, 0){}
  public Person(string name, int age)
  {
    this.name = name;
    this.age = age;
  }
  public void GetInfo()
  {
    Console.WriteLine("Имя:{0} Возрост:{1}", name, age);
  }
}

В данном примере первый конструктор вызывает второй, а второй - третий. 

Классы в C#  поддерживают такие концепции объектно-ориентированного программирования (ООП), как инкапсуляция, наследование и полиморфизм. 

Понятие инкапсуляции в ООП подразумевает: 
1) возможность размещения в одном компоненте данных и функций (методов), которые с ними работают;
2) скрытие внутренней реализации от других компонентов (в этом случае доступ к скрытому атрибуту предоставляться не напрямую, а с помощью специальных матодов чтения (геттер) и изменения (сеттер)). 

Для задания режима доступа к члену класса в  C# используются следующие основные модификаторы: 
*public - общедоступный класс или член класса (доступен из любого места в коде, а также из других программ и сборок);
*private - закрытый класс или член класса (доступен только из кода в том же классе или контексте);
*protected - член класс, доступный из любого места в текущем классе или в производных классах.

Например: 

using System;
namespace hello
{
  public class Complex
  {
    //Описание полей
    private double re;
    private double im;
    
    //Описание методов
    Complex()
    {
      re = im = 0;
    }
    public Complex(double r, double i)
    {
      re = r;
      im = i;
    }
    
    public void set (double r, double i)
    {
      re = r;
      im = i;
    }

    public void get(ref double r, ref double i)
    {
      r = re;
      i = im;
    }

  }

  class Program
  {
    static void Main(string[] args)
    {
      Complex i = new Complex(0, 1);
      double re = 0, im = 0;

      i.get(ref re, ref im);
      Console.WriteLine("re = {0}, im = {1}", re, im);
    }
  }
}

Наследование в ООП - концепция, согласно которой тип данных (класс) может наследовать данные и функциональность некоторого уже существующего типа (класса), что способствует повторному использованию компонентов программного обеспечения. 

Например: 

abstract class Vehicule // Абстрактный класс "Транспортное средство"
{
  virtual public void GetInfo() {}
}
class Truck : Vehicule // Класс "Грузовой автомобиль"
{
  public override void GetInfo()
  {
    Console.WriteLine("Truck");
  }
}
class Car: Vehicule // класс "Легковой автомобиль"
{
  public override void GetInfo()
  {
    Console.WriteLine("Passenger car");
  }
}

Полиморфизм - это возможность методов различных объектов иметь одинаковый интерфейс, но отличаться по своему содержанию. 
Эта возможность реализуется путем переорпеделениея метода родительского класса в классе наследнике. 

Рассмотрим следующий пример для ранее приведенных классов Vehicule - Truck - Car:

// ... 
Vehicule[] v = new Vehicule[2];

v[0] = new Car();
v[1] = new Truck();

foreach (Vehicle it in v)
   it.GetInfo();

Для передачи параметров в конструктор базового класса используется ключевое слово base. Например: 

abstract class Vehicle // Абстрактный класс "Транспортное средство"
{
  protected string type; // Тип транспортного средства
  protected string model; // Модель
  public Vehicule(string t, string m)
  {
    type = t;
    model = m;

  }
  // ...
}
class Truck : Vehicle // Класс "Грузовик"
{
  private int carrying;
  public Truck(string t, string m, int c) : base(t, m)
  {
    carrying = c;
  }
  // ...
}

В языке C# в отличие от языка C++ запрещено множественное наследование классов. 
Для реализации этого функционала применяются так называемые интерфейсы. 

Интерфейсом в C# называется специальный тип ссылок, содержащий только абстрактные элементы, не имеющие реализации. 
Непосредтвенная их реализация должна содержаться в классе, производном от этого интерфейса. 

Пусть, например, требуется реализовать систему классов, описывающих различиные геометрические фигуры. 
Абстрактный базовый класс CShape (форма) можно реализовать такими образом: 

// Абстрактная геометрическая фигура 
abstract class CShape
{
  public abstract string GetName(); // Название фигуры 
}

А соответствующий интерфейс, содержащий метод вычисления площади фигуры, так: 

interface IShape
{
  double Square();
}

Тогда, например, класс, описыващий прямоугольник, можно реализовать таким образом: 

// Класс, описывающий прямоугольник 
class CRectangle : CShape, IShape
{
  private double width; //Ширина и высота
  private double height;
  public CRectangle(double w, double h)
  {
    width = w;
    height = h;
  }
  public double Square() //Реализация интерфейсного метода вычисления площади
  {
    return width * height;
  }
  public override string GetName()
  {
    return "Square";
  }
}

Интерфейсы Аналогичным образом можно описать класс для окружности: 

// Класс, описывающий окружность 
class CCircle : CShape, IShape
{
  private double radius;
  public CCircle(double r)
  {
    radius = r;
  }
  public double Square()
  {
    return Math.PI * radius * radius;
  }
  public override string GetName()
  {
    return "Circle";
  }
}

Таким образом, классы CRectangle и CCircle являются производными от Cshape и реализуют метод Square() интерфейса IShape.

4. Перегрузка операторов 

Хорошо спроектированный класс должен быть таким же удобынм в использовании, как и встроенный в язык тип данных. 
Для этого в классах используется перегрузка операторов. 

Она заключается в определении в классе, для объектов которго требуется определить оператор, специального метода operator, синтаксис которого имеет следующий вид: 

public static <возвращаемый_тип> operator <оператор>(<параметры>)
{
  // ...
}

(a + b) * (c + d)

Примечание: при реализации методов, перегружающих операции, их параметры изменяться не должны!

Например, реализация класса, инкапсулирующего понятие двухмерного вектора с перегруженнымим операторами, может иметь такой вид: 

class Vector2D
{
  private double x; // Координаты вектора
  private double y;
  public Vector2D(double px, double py)
  {
    x = px;
    y = py;
  }
  public static Vector2D operator + (Vector2D lhs, Vector2D rhs) // Перегрузка бинарной операции
  {
    return new Vector2D(lhs.x + rhs.x, lhs.y + rhs.y); // Возврат нового объекта
  }
  public static Vector2D operator - (Vector2D rhs) // Перегрузка унарной операции
  {
    return new Vector2D(-rhs.x, -rhs.y);
  }
  public void print()
  {
    Console.WriteLine("({0}, {1})", x, y);
  }
}

Пример использования перегруженных операций может иметь следующий вид: 

// ...
Vector2D i = new Vector2D(1,0),
         j = new Vector2D(0,1),
         sum = i + j;

sum.print();
sum = - sum;
sum.print();

//...

5. Преобразование типов 

На практике часто возникает необходимость в преобразовании типов объектов. 
Рассмотрим иерархию ранее рассмотренных классов Vehicle - Truck - Car: 

      Object 
        ^
        |
      Vehicle
      (Object)
        ^
        |
   |----|----|
   |         |
  Truck     Car
(Vehicule)   (Vehicle)

Примечание: все классы в .NET ( в т.ч. и те, которые создаются программистами) являются неявно производными от класса System.Object, который находися на вершине иерархии наследования. 
Поэтому все типы и классы могут реализовать те методы, которые определены в классе Object.

В C# реализованы восходящие и нисходящие преобразования типов. 

Восходящие преобразования (upcasting)
Объекты дочернего типа также относятся и к базовому типу. 
Например, объект Truck(грузовик) в то же время является и объектом класса Vehicle (транспортное средство). Следовательно, можно написать, например, следующий код: 

Truck truck = new Truck();
Vehicule vechile = truck; // Неявное восходящее преобразование 

vehicule.GetInfo();

Исходящие преобразования (downcasting)
Другим типом преобразования является нисходящее преобразование - от базового типа к производному. Следует отметить, что такой вид преобразования не всегда возможен, как, например, в данном случае, т.к. первоначально созадть объект абстрактного класса Vehicle нельзя.

Явные способы преобразований

1. Используя ключевое слово as можно выполнить попытку преобразования выражения к определенному типу. 
В случае неудачного пробразования выражение будет содержать значение null (исключительная ситуация не генерируется) . Например: 

Truck truck = new Truck();
Vehicule car = truck as Vehicle;

if (car != null)
  car.Getinfo();
else
  Console.WriteLine("Error!");

2. Проверка допустимости преобразования с помощью ключевого слова is: 

Car car = new Car();
Vehicle vehicle;

if (car is Vehicle)
{
  vehicle = car; 
  vehicle.GetInfor();
}
else
  Console.WriteLine("Error!");


6. Класс  System.Object 

Как уже отмечалось, все классы в .NET являются наследниками от базового класса System.Object.
К его основным методам относятся:

1. Метод ToString() служит для получения строкового представления данного объекта. 
Для базовых типов просто будет выводиться их строковое знаечени

Truck truck = new Truck;
Console.WriteLine(truck.ToString());


2. Метод GetHashCode() позволяет возвратить некоторое числовое значение (хэш-код), соответсующее данному объекту:

Truck truck = new Truck();

Console.WriteLine(truck.GetHashCode());

3. Метод Equals() позволяет сравнить два объекта на равненство: 


Сщтудывлаоывла
